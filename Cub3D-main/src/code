/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   events.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jedurand <jedurand@student.42perpignan.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/07/23 17:26:16 by jeguerin          #+#    #+#             */
/*   Updated: 2024/08/27 23:07:20 by jedurand         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../cub3D.h"

int	manage_keypress(int keycode, t_game *game)
{
	if (keycode == KEY_ESC)
		free_all2(game);
	else if (keycode == KEY_W)
		game->touch_state[W_INDEX] = 1;
	else if (keycode == KEY_A)
		game->touch_state[A_INDEX] = 1;
	else if (keycode == KEY_S)
		game->touch_state[S_INDEX] = 1;
	else if (keycode == KEY_D)
		game->touch_state[D_INDEX] = 1;
	else if (keycode == KEY_LEFT)
		game->touch_state[LEFT_INDEX] = 1;
	else if (keycode == KEY_RIGHT)
		game->touch_state[RIGHT_INDEX] = 1;
	return (0);
}

int	manage_keyrelease(int keycode, t_game *game)
{
	if (keycode == KEY_W)
		game->touch_state[W_INDEX] = 0;
	else if (keycode == KEY_A)
		game->touch_state[A_INDEX] = 0;
	else if (keycode == KEY_S)
		game->touch_state[S_INDEX] = 0;
	else if (keycode == KEY_D)
		game->touch_state[D_INDEX] = 0;
	else if (keycode == KEY_LEFT)
		game->touch_state[LEFT_INDEX] = 0;
	else if (keycode == KEY_RIGHT)
		game->touch_state[RIGHT_INDEX] = 0;
	return (0);
}

// void	is_action(t_game *game)
// {
// 	if (game->touch_state[W_INDEX])
// 		update_position(game, game->player.dir_x * game->player.speed,
// 			game->player.dir_y * game->player.speed);
// 	else if (game->touch_state[A_INDEX])
// 		update_position(game, game->player.dir_y * game->player.speed,
// 			-game->player.dir_x * game->player.speed);
// 	else if (game->touch_state[S_INDEX])
// 		update_position(game, -game->player.dir_x * game->player.speed,
// 			-game->player.dir_y * game->player.speed);
// 	else if (game->touch_state[D_INDEX])
// 		update_position(game, -game->player.dir_y * game->player.speed,
// 			game->player.dir_x * game->player.speed);
// 	else if (game->touch_state[LEFT_INDEX])
// 		rotate_player(game, -1);
// 	else if (game->touch_state[RIGHT_INDEX])
// 		rotate_player(game, 1);
// }

// Function to try moving the player and handle collisions
void try_move(t_game *game, double move_x, double move_y)
{
    double new_x = game->player.x + move_x;
    double new_y = game->player.y + move_y;

    // Check collision at the player's center
    if (!is_wall(game, new_x, game->player.y)) // Move along X axis if no collision
    {
        game->player.x = new_x;
    }
    if (!is_wall(game, game->player.x, new_y)) // Move along Y axis if no collision
    {
        game->player.y = new_y;
    }
}
void is_action(t_game *game)
{
    double move_x = 0;
    double move_y = 0;

    // Reduce movement speed by using smaller increments
    double movement_speed = game->player.speed * 0.05; // Adjust this value to reduce speed

    int is_moving = 0;

    if (game->touch_state[W_INDEX]) // Move forward
    {
        move_x += game->player.dir_x * movement_speed;
        move_y += game->player.dir_y * movement_speed;
        is_moving = 1;
    }
    if (game->touch_state[S_INDEX]) // Move backward
    {
        move_x -= game->player.dir_x * movement_speed;
        move_y -= game->player.dir_y * movement_speed;
        is_moving = 1;
    }
    if (game->touch_state[A_INDEX]) // Strafe left
    {
        move_x -= game->player.plane_x * movement_speed;
        move_y -= game->player.plane_y * movement_speed;
        is_moving = 1;
    }
    if (game->touch_state[D_INDEX]) // Strafe right
    {
        move_x += game->player.plane_x * movement_speed;
        move_y += game->player.plane_y * movement_speed;
        is_moving = 1;
    }

    // Check for wall collisions
    try_move(game, move_x, move_y);

    // Adjust the walk offset if the player is moving
    if (is_moving)
    {
        game->frame_count++;
        game->walk_offset = (int)(sin(game->frame_count * 0.1) * 10); // Adjust the multiplier (10) for stronger effect
    }
    else
    {
        // Reset walk offset if the player stops moving
        game->walk_offset = 0;
        game->frame_count = 0; // Optionally reset the frame count when stopping
    }
}




// events.c
// int	manage_mouse_movement(int x, t_game *game)
// {
//     int dx;

// 	//TODO this was to stop fonction from working
//     return 0;  // Prevent using uninitialized or null values


//     // Calcul du déplacement de la souris en X
//     dx = x - game->input.last_mouse_x;
//     game->input.last_mouse_x = x;

//     // Appliquer la rotation en fonction du déplacement de la souris
//     if (dx != 0) {
//         rotate_player(game, -dx * 0.003);  // Ajuster la sensibilité de la souris si nécessaire
//     }
//     return (0);
// }

int	manage_mouse_movement(int x, int y, t_game *game)
{
	double	angle;
	int		dx;

	(void)y;
	if (x == game->input.last_mouse_x)
		game->input.last_mouse_x = x;
	dx = x - game->input.last_mouse_x;
	game->input.last_mouse_x = x;
	angle = dx * 0.003;
	rotate_player(game, angle);
	return (0);
}

int manage_mouse_click(int button, int x, int y, t_game *game)
{
    (void)x;
    (void)y;
    if (button == 1 || button == 3) // Clic gauche ou droit
    {
        if (game->gun_shot == 0) // Si pas de tir en cours
        {
            game->gun_shot = 1;
            game->shot_frame = 0;
            // create_ball(game, button);
        }
    }
    return (0);
}
#include "../cub3D.h"

void render_scene(t_game *game, t_texture *frame)
{
    int x;

    // Variables needed for raycasting
    double camera_x, ray_dir_x, ray_dir_y;
    int map_x, map_y;
    double side_dist_x, side_dist_y;
    double delta_dist_x, delta_dist_y;
    double perp_wall_dist;
    int step_x, step_y;
    int hit, side;

    // Ceiling and floor colors
    int ceiling_color = (game->ceiling.r << 16) | (game->ceiling.g << 8) | game->ceiling.b;
    int floor_color = (game->floor.r << 16) | (game->floor.g << 8) | game->floor.b;

    // Loop through each vertical stripe of the screen
    for (x = 0; x < game->win_width; x++)
    {
        // Calculate ray position and direction
        camera_x = 2 * x / (double)game->win_width - 1;
        ray_dir_x = game->player.dir_x + game->player.plane_x * camera_x;
        ray_dir_y = game->player.dir_y + game->player.plane_y * camera_x;

        // Which box of the map we're in
        map_x = (int)game->player.x;
        map_y = (int)game->player.y;

        // Length of ray from current position to next x or y-side
        delta_dist_x = fabs(1 / ray_dir_x);
        delta_dist_y = fabs(1 / ray_dir_y);

        // Calculate step and initial side_dist
        if (ray_dir_x < 0)
        {
            step_x = -1;
            side_dist_x = (game->player.x - map_x) * delta_dist_x;
        }
        else
        {
            step_x = 1;
            side_dist_x = (map_x + 1.0 - game->player.x) * delta_dist_x;
        }
        if (ray_dir_y < 0)
        {
            step_y = -1;
            side_dist_y = (game->player.y - map_y) * delta_dist_y;
        }
        else
        {
            step_y = 1;
            side_dist_y = (map_y + 1.0 - game->player.y) * delta_dist_y;
        }

        // Perform DDA (Digital Differential Analysis)
        hit = 0;
        while (hit == 0)
        {
            // Jump to next map square in x or y direction
            if (side_dist_x < side_dist_y)
            {
                side_dist_x += delta_dist_x;
                map_x += step_x;
                side = 0;
            }
            else
            {
                side_dist_y += delta_dist_y;
                map_y += step_y;
                side = 1;
            }
            // Check if ray has hit a wall
            if (game->map.map[map_x][map_y] == '1')
                hit = 1;
        }

        // Calculate distance to the point of impact
        if (side == 0)
            perp_wall_dist = (map_x - game->player.x + (1 - step_x) / 2) / ray_dir_x;
        else
            perp_wall_dist = (map_y - game->player.y + (1 - step_y) / 2) / ray_dir_y;

        // Calculate height of line to draw on screen
        int line_height = (int)(game->win_height / perp_wall_dist);

        // Calculate lowest and highest pixel to fill in current stripe
        int draw_start = -line_height / 2 + game->win_height / 2 + game->walk_offset;
        if (draw_start < 0) draw_start = 0;
        int draw_end = line_height / 2 + game->win_height / 2 + game->walk_offset;
        if (draw_end >= game->win_height) draw_end = game->win_height - 1;

        // Choose a random color for each wall side (as a placeholder)
        int wall_color = 0xFFFFFF; // default white
        if (side == 0)
        {
            if (step_x > 0) wall_color = 0xFF0000; // Red for East wall
            else wall_color = 0x00FF00; // Green for West wall
        }
        else
        {
            if (step_y > 0) wall_color = 0x0000FF; // Blue for South wall
            else wall_color = 0xFFFF00; // Yellow for North wall
        }

        // Draw the ceiling (from top to draw_start)
		// Instead of using game->mini_map, you should use the frame
		for (int y = 0; y < draw_start; y++)
			my_mlx_pixel_put(frame, x, y, ceiling_color);  // Use frame

		// Drawing the wall
		for (int y = draw_start; y < draw_end; y++)
			my_mlx_pixel_put(frame, x, y, wall_color);  // Use frame

		// Drawing the floor
		for (int y = draw_end; y < game->win_height; y++)
			my_mlx_pixel_put(frame, x, y, floor_color);  // Use frame
    }
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init2.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jeguerin <jeguerin@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/07/25 09:36:20 by jeguerin          #+#    #+#             */
/*   Updated: 2024/08/27 12:05:48 by jeguerin         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../cub3D.h"

void	init_color(t_color *color)
{
	color->r = 0;
	color->g = 0;
	color->b = 0;
}

void	init_texture(t_texture *texture)
{
	texture->img = NULL;
	texture->addr = NULL;
	texture->pixel_bits = 0;
	texture->size_line = 0;
	texture->endian = 0;
	texture->width = 0;
	texture->height = 0;
}

void	init_input(t_input *input)
{
	input->mouse_x = 0;
	input->mouse_y = 0;
	input->last_mouse_x = -1;
	input->last_mouse_y = 0;
	input->mouse_left_pressed = 0;
}

void	init_ceiling_colors(t_game *game, int r, int g, int b)
{
	game->ceiling.r = r;
	game->ceiling.g = g;
	game->ceiling.b = b;
}

void	init_floor_colors(t_game *game, int r, int g, int b)
{
	game->floor.r = r;
	game->floor.g = g;
	game->floor.b = b;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: marvin <marvin@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/07/08 13:57:03 by marvin            #+#    #+#             */
/*   Updated: 2024/07/08 13:57:03 by marvin           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../cub3D.h"

void	init_player(t_player *player)
{
	player->x = 0;
	player->y = 0;
	player->dir_x = 0;
	player->dir_y = 0;
	player->plane_x = 0;
	player->plane_y = 0.66;
	player->speed = 0.05;
	player->rot_speed = 0.04;
}
// speed : vitesse du player en pixels.

// memset(game->texture_paths, 0, sizeof(game->texture_paths));
void	init_game(t_game *game)
{
	game->win = NULL;
	game->win_height = 800;
	game->win_width = 600;
	game->map.map = NULL;
	game->running = 1;
	game->orientation = 0;
	memset(game->touch_state, 0, sizeof(game->touch_state));
	game->portal_gun.img = NULL;
    game->portal_gun.addr = NULL;
    game->portal_gun.pixel_bits = 0;
    game->portal_gun.size_line = 0;
    game->portal_gun.endian = 0;
	game->gun_shot = 0;
	game->shot_frame = 0;
	init_textures(game);
	init_ball(game);
	load_portal_gun(game);
	game->frame_count = 0;
	game->walk_offset = 0;
}

void	init_map(t_map *map)
{
	map->map = NULL;
	map->height = 0;
	map->width = 0;
}

void init_mini_map(t_game *game)
{
    game->mini_map.width = MINIMAP_WIDTH;
    game->mini_map.height = MINIMAP_HEIGHT;

    // Check for invalid dimensions and handle errors
    if (game->mini_map.width <= 0 || game->mini_map.height <= 0) {
        printf("Error: Invalid mini_map dimensions\n");
        free_all2(game);
        return;
    }
    game->mini_map.img = mlx_new_image(game->mlx, game->mini_map.width, game->mini_map.height);
    if (!game->mini_map.img) {
        printf("Error: Failed to create mini_map image\n");
        free_all2(game);
    }

    game->mini_map.addr = (int *)mlx_get_data_addr(game->mini_map.img, &game->mini_map.pixel_bits, &game->mini_map.size_line, &game->mini_map.endian);
    if (!game->mini_map.addr) {
        printf("Error: Failed to get mini_map data address\n");
        mlx_destroy_image(game->mlx, game->mini_map.img);
        free_all2(game);
    }
}

void	init_ball(t_game *game)
{
	int	i;

	i = 0;
	while (i < 2)
	{
		game->ball[i].texture.img = NULL;
		game->ball[i].texture.addr = NULL;
		game->ball[i].texture.pixel_bits = 0;
		game->ball[i].texture.size_line = 0;
		game->ball[i].texture.endian = 0;
		game->ball[i].texture.width = 64;
		game->ball[i].texture.height = 64;
		game->ball[i].x = 0;
		game->ball[i].y = 0;
		game->ball[i].direction_x = 0;
		game->ball[i].direction_y = 0;
		game->ball[i].active = 0;
		i++;
	}
	load_ball_textures(game);

}

void	init_textures(t_game *game)
{
	int	i;

	i = 0;
	while (i < 4)
	{
		game->textures[i].addr = NULL;
		game->textures[i].img = NULL;
		game->textures[i].pixel_bits = 0;
		game->textures[i].size_line = 0;
		game->textures[i].endian = 0;
		game->textures[i].width = 0;
		game->textures[i].height = 0;
		i++;
	}
}

void	init_cub(t_game *game)
{
	init_game(game);
	init_player(&game->player);
	init_color(&game->floor);
	init_color(&game->ceiling);
	init_texture(game->textures);
	init_map(&game->map);
	init_input(&game->input);
	init_mini_map(game);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: marvin <marvin@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/07/08 13:02:21 by marvin            #+#    #+#             */
/*   Updated: 2024/07/08 13:02:21 by marvin           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../cub3D.h"

void	create_textures(t_game *game)
{
	int	i;

	i = 0;
	while (i < 4)
	{
		game->textures[i].img = mlx_xpm_file_to_image(game->mlx,
				game->texture_paths[i], &game->textures[i].width,
				&game->textures[i].height);
		if (!game->textures[i].img)
		{
			printf("Could not create mlx image\n");
			free_all2(game);
		}
		game->textures[i].addr = (int *)mlx_get_data_addr(game->textures[i].img,
				&game->textures[i].pixel_bits, &game->textures[i].size_line,
				&game->textures[i].endian);
		i++;
	}
}

// TO ADD : mlx_mouse_hook(data.window, handle_mouse, &data);
// Handle mouse events (left click to select)
void	create_window(t_game *game)
{
	if (game->mlx == NULL)
	{
		printf("Mlx has not been set up\n");
		return ;
	}
	game->win = mlx_new_window(game->mlx, 800, 800,
			"Cub3d - A portail's world");
	if (!game->win)
	{
		printf("Could not create mlx window\n");
		return ;
	}
	mlx_hook(game->win, 2, 1L << 0, manage_keypress, game);
	mlx_hook(game->win, 3, 1L << 1, manage_keyrelease, game);
	mlx_hook(game->win, 4, 1L << 2, manage_mouse_click, game);
	mlx_hook(game->win, 17, KeyPressMask, free_all2, game);
	mlx_loop_hook(game->mlx, display_each_frame, game);
	mlx_hook(game->win, MotionNotify, PointerMotionMask, manage_mouse_movement,
		game);
	mlx_do_key_autorepeatoff(game->mlx);
	mlx_loop(game->mlx);
}

// Init structures
// Create map
// Check map errors
int	main(int argc, char *argv[])
{
	t_game	game;
	char	*map;

	if (argc != 2)
		return (printf("Wrong nb of arguments\n"), 1);
	map = ft_strdup(argv[1]);
	if (!map)
		return (printf("There is no map\n"), 1);
	game.mlx = mlx_init();
	if (!game.mlx)
		return (printf("Could not start mlx\n"), 1);
	init_cub(&game);
	read_map(&game, map);
	malloc_map(&game);
	fill_map(&game, map);
	manage_errors(&game, map);
	// create_textures(&game);
	create_window(&game);
	mlx_loop(game.mlx);
	free(map);
	free_all2(&game);
	return (0);
}

#include "../cub3D.h"

void draw_pixel(t_texture *img, int x, int y, int color)
{
    if (x >= 0 && x < img->width && y >= 0 && y < img->height) // Check bounds
    {
        char *dst = (char *)img->addr + (y * img->size_line + x * (img->pixel_bits / 8));
        *(unsigned int *)dst = color;
    }
}

void draw_mini_map(t_game *game)
{
    int x, y;
    int map_x, map_y;

    // Iterate over each pixel of the minimap
    for (y = 0; y < game->mini_map.height; y++)
    {
        for (x = 0; x < game->mini_map.width; x++)
        {
            // Calculate corresponding map coordinates
            map_x = (int)((game->player.x - game->mini_map.width / 2 / T_SIZE) + x / T_SIZE);
            map_y = (int)((game->player.y - game->mini_map.height / 2 / T_SIZE) + y / T_SIZE);

            //printf("Map Coordinates: map_x = %d, map_y = %d, for pixel x = %d, y = %d\n", map_x, map_y, x, y);
			//printf("Player Position: x = %f, y = %f\n", game->player.x, game->player.y);


            // Check map boundaries and draw walls or empty spaces
            if (map_x >= 0 && map_x < game->map.width && map_y >= 0 && map_y < game->map.height)
            {
                if (game->map.map[map_y][map_x] == '1')
                    draw_pixel(&game->mini_map, x, y, 0xFFFFFF); // Wall in white
                else
                    draw_pixel(&game->mini_map, x, y, 0x888888); // Empty space in gray
            }
            else
            {
                draw_pixel(&game->mini_map, x, y, 0x555555); // Out of bounds in dark gray
            }
        }
    }

    // Draw the player as a bigger square (6x6 pixels) in the minimap's center
    int player_size = 6; // Adjust the size of the player on the minimap
    for (int i = -player_size / 2; i <= player_size / 2; i++)
    {
        for (int j = -player_size / 2; j <= player_size / 2; j++)
        {
            draw_pixel(&game->mini_map, game->mini_map.width / 2 + i, game->mini_map.height / 2 + j, 0xFF0000); // Player in red
        }
    }
}

void    draw(t_texture *img, int x, int y, int color)
{
    int i;
    int j;
    double pixel_x;
    double pixel_y;

    i = 0;
    while (i < T_SIZE)
    {
        j = 0;
        while (j < T_SIZE)
        {
            pixel_x = x * T_SIZE + j;
            pixel_y = y * T_SIZE + i;
            if (pixel_x < img->width && pixel_y < img->height)
                my_mlx_pixel_put(img, (int)pixel_x, (int)pixel_y, color);
            j++;
        }
        i++;
    }
}

void draw_player(t_game *game, t_texture *mini_map)
{
    int player_x = M_SIZE / 2;
    int player_y = M_SIZE / 2;

    // Draw the player as a small red square
    for (int i = -2; i <= 2; i++)
    {
        for (int j = -2; j <= 2; j++)
        {
            draw(mini_map, player_x + j, player_y + i, 0xFF0000); // Red color for the player
        }
    }

    // Draw the player's view direction
    draw_view_direction(game, mini_map);
}


int is_wall(t_game *game, double x, double y)
{
    int map_x = (int)x;
    int map_y = (int)y;

    // Check boundaries and return if it's a wall
    if (map_x < 0 || map_x >= game->map.width || map_y < 0 || map_y >= game->map.height)
        return 1; // Out of bounds treated as a wall
    if (game->map.map[map_y][map_x] == '1')
        return 1; // Wall
    return 0; // No wall
}



void draw_view_direction(t_game *game, t_texture *mini_map)
{
    double map_x, map_y;
    double player_x = M_SIZE / 2 * T_SIZE;
    double player_y = M_SIZE / 2 * T_SIZE;

    // Draw a line representing the player's view direction
    for (int i = 0; i < 40; i++)
    {
        map_x = player_x + i * game->player.dir_x;
        map_y = player_y + i * game->player.dir_y;

        if (is_wall(game, (int)(game->player.x + i * game->player.dir_x), (int)(game->player.y + i * game->player.dir_y)))
            break;

        draw(mini_map, (int)(map_x / T_SIZE), (int)(map_y / T_SIZE), 0xFF0000); // Red color for the direction
    }
}

void my_mlx_pixel_put(t_texture *img, int x, int y, int color)
{
    char *dst;

    if (x >= 0 && x < img->width && y >= 0 && y < img->height)
    {
        dst = (char *)img->addr + (y * img->size_line + x * (img->pixel_bits / 8));
        *(unsigned int *)dst = color;
    }
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   move_player.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jedurand <jedurand@student.42perpignan.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/07/29 16:54:27 by jeguerin          #+#    #+#             */
/*   Updated: 2024/08/27 23:16:30 by jedurand         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../cub3D.h"

// void	check_map_path(double x, double y, t_game *game)
// {
// 	if (game->map.map[y][x] != '1')
// 	{
// 		mlx_put_image_to_window(game->mlx, game->win, game->floor.b,
//			game->player.x, game->player.y);
// 		game->player.x = x;
// 		game->player.y = y;
// 		mlx_put_image_to_window(game->mlx, game->win, game->ceiling.r,
//			game->player.x, game->player.y);
// 	}
// }

// printf("Map-x : %d\n", map_x);
	// printf("Width : %d\n", game->map.width);
	// printf("Height : %d\n", game->map.height);
int	is_outside(t_game *game, double x, double y)
{
	int	map_x;
	int	map_y;

	map_x = (int)x;
	map_y = (int)y;
	if (map_x < 0 || map_x >= game->map.width || map_y < 0
		|| map_y >= game->map.height)
		return (1);
	if (game->map.map[map_y][map_x] == ' '
		|| game->map.map[map_y][map_x] == '1')
		return (1);
	return (0);
}

// void	update_position(t_game *game, double move_x, double move_y)
// {
// 	double	new_x;
// 	double	new_y;

// 	new_x = game->player.x + move_x;
// 	new_y = game->player.y + move_y;
// 	if (!is_outside(game, new_x, new_y))
// 	{
// 		game->player.x = new_x;
// 		game->player.y = new_y;
// 	}
// 	else
// 	{
// 		if (!is_outside(game, new_x, game->player.y))
// 			game->player.x = new_x;
// 		if (!is_outside(game, game->player.x, new_y))
// 			game->player.y = new_y;
// 	}
// 	printf("New position x : %f\n", game->player.x);
// 	printf("New position y : %f\n", game->player.y);
// }


void update_position(t_game *game, double move_x, double move_y)
{
    double new_x = game->player.x + move_x;
    double new_y = game->player.y + move_y;

    // Check for wall collisions and update player position accordingly
    if (!is_wall(game, new_x, game->player.y))
    {
        game->player.x = new_x;
    }
    if (!is_wall(game, game->player.x, new_y))
    {
        game->player.y = new_y;
    }

	printf("Updated Player Position: x = %f, y = %f\n", game->player.x, game->player.y);
}


// void	rotate_player(t_game *game, double angle)
// {
// 	double	old_dir_x;
// 	double	old_dir_y;
// 	double	old_plane_x;
// 	double	old_plane_y;

// 	old_dir_x = game->player.dir_x;
// 	old_dir_y = game->player.dir_y;
// 	old_plane_x = game->player.plane_x;
// 	old_plane_y = game->player.plane_y;
// 	// printf("angle : %f\n", angle);
// 	angle *= game->player.rot_speed;
// 	printf("After angle : %f\n", angle);
// 	game->player.dir_x = old_dir_x * cos(angle) - old_dir_y * sin(angle);
// 	game->player.dir_y = old_dir_x * sin(angle) + old_dir_y * cos(angle);
// 	game->player.plane_x = old_plane_x * cos(angle) - old_plane_y * sin(angle);
// 	game->player.plane_y = old_plane_x * sin(angle) + old_plane_y * cos(angle);
// 	// printf("dir_x : %f\n", game->player.dir_x);
// 	// printf("dir_y : %f\n", game->player.dir_y);
// 	// printf("plane_x : %f\n", game->player.plane_x);
// 	// printf("plane_y : %f\n", game->player.plane_y);
// }

void rotate_player(t_game *game, double angle)
{
    double old_dir_x = game->player.dir_x;
    double old_plane_x = game->player.plane_x;

    // Apply rotation using cosine and sine for smooth rotation
    game->player.dir_x = old_dir_x * cos(angle) - game->player.dir_y * sin(angle);
    game->player.dir_y = old_dir_x * sin(angle) + game->player.dir_y * cos(angle);

    game->player.plane_x = old_plane_x * cos(angle) - game->player.plane_y * sin(angle);
    game->player.plane_y = old_plane_x * sin(angle) + game->player.plane_y * cos(angle);
}

// void    display_mini_map(t_game *game, t_texture *frame)
// {
//     t_texture mini_map;

//     (void)frame;
//     mini_map.width = M_SIZE * T_SIZE;
//     mini_map.height = M_SIZE * T_SIZE;
//     mini_map.img = mlx_new_image(game->mlx, mini_map.width, mini_map.height);
//     mini_map.addr = mlx_get_data_addr(mini_map.img, &mini_map.pixel_bits, &mini_map.size_line, &mini_map.endian);
//     draw_mini_map(game, &mini_map);
//     draw_player(game, &mini_map);
//     mlx_put_image_to_window(game->mlx, game->win, mini_map.img, 10, 10); // Positionne la mini-map
//     mlx_destroy_image(game->mlx, mini_map.img);
// }

int display_each_frame(t_game *game)
{
    // Clear the frame
    t_texture frame;
    frame.width = game->win_width;
    frame.height = game->win_height;
    frame.img = mlx_new_image(game->mlx, frame.width, frame.height);
    frame.addr = (int *)mlx_get_data_addr(frame.img, &frame.pixel_bits, &frame.size_line, &frame.endian);

    // Set frame as the active texture for drawing
    game->mini_map = frame;

    // Render the scene (walls, floor, ceiling)
    render_scene(game, &frame);

    // Render the minimap to the window
    draw_mini_map(game);  // Update minimap content
    mlx_put_image_to_window(game->mlx, game->win, game->mini_map.img, 10, 10); // Minimap position on the window

    // Display the rendered frame
    mlx_put_image_to_window(game->mlx, game->win, frame.img, 0, 0); // Full scene on window

    // Clean up the frame resources
    mlx_destroy_image(game->mlx, frame.img);

    // Handle player movement and actions
    is_action(game);
    display_portal_gun(game); // Handle gun display

    return 0;
}




/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils2.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jeguerin <jeguerin@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/07/25 11:52:19 by jeguerin          #+#    #+#             */
/*   Updated: 2024/07/29 16:21:27 by jeguerin         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../cub3D.h"

// game->texture_paths && game->texture_paths[i]
void	free_everything(t_game *game)
{
	int	i;

	i = 0;
	while (i < 4)
	{
		if (game->texture_paths[i])
			free(game->texture_paths[i]);
		i++;
	}
	if (game->win != NULL)
	{
		mlx_destroy_window(game->mlx, game->win);
		game->win = NULL;
	}
	if (game->mlx != NULL)
	{
		mlx_destroy_display(game->mlx);
		free(game->mlx);
	}
}

// printf("Line %s\n", game->map.map[i]);
int	free_all2(t_game *game)
{
	int	i;

	printf("OK free \n");
	mlx_do_key_autorepeatoff(game->mlx);
	if (game->map.map)
	{
		i = 0;
		while (i < game->map.height)
		{
			if (game->map.map[i] != NULL)
				free(game->map.map[i]);
			i++;
		}
		free(game->map.map);
	}
	// for (i = 0; i < 4; i++)
    // {
    //     if (game->textures[i].img)
    //         mlx_destroy_image(game->mlx, game->textures[i].img);
    // }
    // if (game->portal_gun.img)
    //     mlx_destroy_image(game->mlx, game->portal_gun.img);
    if (game->mini_map.img)
	{
        mlx_destroy_image(game->mlx, game->mini_map.img);
	}
	free_everything(game);
	exit(EXIT_SUCCESS);
	return (0);
}

int	check_char(char const *set, char c)
{
	int	i;

	i = 0;
	while (set[i])
	{
		if (set[i] == c)
			return (1);
		i++;
	}
	return (0);
}

int	only_space2(char *line)
{
	while (*line)
	{
		if (*line != ' ' && *line != '\t' && *line != '\n' && *line != '\r')
			return (0);
		line++;
	}
	return (1);
}

int	only_space(char *line)
{
	int	i;

	i = 0;
	while (line[i])
	{
		if (!isspace(line[i]))
			return (0);
		i++;
	}
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jeguerin <jeguerin@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/07/10 09:24:13 by jeguerin          #+#    #+#             */
/*   Updated: 2024/07/25 11:52:52 by jeguerin         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../cub3D.h"

int	ft_isspace(char *line)
{
	size_t	i;

	i = 0;
	while (line[i])
	{
		if (line[i] <= 9 || line[i] >= 13 || line[i] != 32)
			return (1);
		i++;
	}
	return (0);
}
// Exit useful ?

int	how_many_signs(const char *nptr, int sign, int i)
{
	if (nptr[i + 1] == 45 || nptr[i + 1] == 43)
		return (0);
	if (nptr[i] == 45)
		sign = -1;
	return (sign);
}

int	skip_spaces(const char *nptr, int i)
{
	while (nptr[i] == 32 || (nptr[i] >= 9 && nptr[i] <= 13))
		i++;
	return (i);
}

int	ft_atoi2(const char *nptr)
{
	int		i;
	int		sign;
	int		result;
	int		check;

	i = 0;
	sign = 1;
	result = 0;
	check = -1;
	i = skip_spaces(nptr, i);
	if (nptr[i] == 43 || nptr[i] == 45)
	{
		sign = how_many_signs(nptr, sign, i);
		if (sign == 0)
			return (1);
		i++;
	}
	while (nptr[i] >= 48 && nptr[i] <= 57)
	{
		result = result * 10 + (nptr[i++] - '0');
		check = 0;
	}
	if (check == -1)
		return (-1);
	return (result * sign);
}
// TO TEST WITH THE i !!

int	ft_strncmp_cub(const char *s1, char c, size_t n)
{
	size_t	i;

	i = 0;
	if (n == 0)
		return (0);
	while (s1[i] == 32)
		i++;
	while ((unsigned char)s1[i] && ((unsigned char)s1[i]
			== (unsigned char)c) && (i < n - 1))
	{
		printf("Char : %c\n", s1[i]);
		i++;
	}
	if (i == n - 1)
	{
		printf("OK\n");
		return (0);
	}
	else
		return (1);
}
